// Guard against document not being defined in non-browser environments.
(function() {
    if (typeof global.document === 'undefined') {
        module.exports = function (){};
        return;
    }

    // for compression
    var win = global.window;
    var doc = global.document;
    var root = doc.documentElement || {};

    // detect if we need to use firefox KeyEvents vs KeyboardEvents
    var use_key_event = true;
    try {
        doc.createEvent('KeyEvents');
    }
    catch (err) {
        use_key_event = false;
    }

    // Workaround for https://bugs.webkit.org/show_bug.cgi?id=16735
    function check_kb(ev, opts) {
        if (ev.ctrlKey != (opts.ctrlKey || false) ||
            ev.altKey != (opts.altKey || false) ||
            ev.shiftKey != (opts.shiftKey || false) ||
            ev.metaKey != (opts.metaKey || false) ||
            ev.keyCode != (opts.keyCode || 0) ||
            ev.charCode != (opts.charCode || 0)) {

            ev = document.createEvent('Event');
            ev.initEvent(opts.type, opts.bubbles, opts.cancelable);
            ev.ctrlKey  = opts.ctrlKey || false;
            ev.altKey   = opts.altKey || false;
            ev.shiftKey = opts.shiftKey || false;
            ev.metaKey  = opts.metaKey || false;
            ev.keyCode  = opts.keyCode || 0;
            ev.charCode = opts.charCode || 0;
        }

        return ev;
    }

    // modern browsers, do a proper dispatchEvent()
    var modern = function(type, opts) {
        opts = opts || {};

        // which init fn do we use
        var family = typeOf(type);
        var init_fam = family;
        if (family === 'KeyboardEvent' && use_key_event) {
            family = 'KeyEvents';
            init_fam = 'KeyEvent';
        }

        var ev = doc.createEvent(family);
        var init_fn = 'init' + init_fam;
        var init = typeof ev[init_fn] === 'function' ? init_fn : 'initEvent';

        var sig = initSignatures[init];
        var args = [];
        var used = {};

        opts.type = type;
        for (var i = 0; i < sig.length; ++i) {
            var key = sig[i];
            var val = opts[key];
            // if no user specified value, then use event default
            if (val === undefined) {
                val = ev[key];
            }
            used[key] = true;
            args.push(val);
        }
        ev[init].apply(ev, args);

        // webkit key event issue workaround
        if (family === 'KeyboardEvent') {
            ev = check_kb(ev, opts);
        }

        // attach remaining unused options to the object
        for (var key in opts) {
            if (!used[key]) {
                ev[key] = opts[key];
            }
        }

        return ev;
    };

    var legacy = function (type, opts) {
        opts = opts || {};
        var ev = doc.createEventObject();

        ev.type = type;
        for (var key in opts) {
            if (opts[key] !== undefined) {
                ev[key] = opts[key];
            }
        }

        return ev;
    };

    // expose either the modern version of event generation or legacy
    // depending on what we support
    // avoids if statements in the code later
    module.exports = doc.createEvent ? modern : legacy;

    var initSignatures = require('./init.json');
    var types = require('./types.json');
    var typeOf = (function () {
        var typs = {};
        for (var key in types) {
            var ts = types[key];
            for (var i = 0; i < ts.length; i++) {
                typs[ts[i]] = key;
            }
        }

        return function (name) {
            return typs[name] || 'Event';
        };
    })();
}());
